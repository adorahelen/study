
---

# A.프로그래밍 데이터 이해: 자료형과 알고리즘

데이터는 프로그래밍의 핵심이며, 다양한 방식으로 조직되고 활용됩니다. 
- **일반 자료형(Primitive Types)**, **컬렉션 자료형(Collection Types)**, 그리고 **추상 자료형(Abstract Data Types)**의 관계를 설명하고,
- 이들이 **알고리즘**과 어떻게 연결되는지 보여줍니다.

---

## 1. 데이터 분류 및 역할

### ✅ 1.1. 일반 자료형 (Primitive Types)

가장 기본이 되는 데이터 단위입니다.

* **🔹 기초 재료 역할**
* **🍳 예시:** `int` (정수), `float` (실수), `char` (문자), `bool` (불리언)

### ✅ 1.2. 컬렉션 자료형 (Collection Types)

여러 일반 자료형들을 묶어서 저장하고 다루는 기본적인 틀을 제공합니다.

* **🔹 그릇 역할**
* **🍽 예시:** `List[int]` (정수 리스트), `Map<String, int>` (문자열-정수 맵), `Set<float>` (실수 집합)

### ✅ 1.3. 추상 자료형 (ADT: Abstract Data Type)

문제를 풀기 위한 **개념적 구조**입니다. 자료를 어떻게 조직하고, 어떤 연산을 할지를 정의한 논리적인 구조이며, 주로 알고리즘 문제 해결의 도구로 사용됩니다.

* **🔹 레시피 + 그릇 (자료 구조 + 연산)**
* **🍲 예시:** `Stack`, `Queue`, `Tree`, `Graph`, `Heap`
    * 이들은 실제로는 `List`나 `Map` 같은 컬렉션 자료형을 사용하여 구현됩니다.

---

## 2. 알고리즘과의 관계

**추상 자료형**은 **알고리즘의 기반 구조**가 됩니다. 정렬, 탐색, 최단 경로 찾기 등과 같은 알고리즘은 이러한 추상 자료형 위에서 동작합니다.

* 📦 **일반 자료형들**로 → **컬렉션(그릇)**을 만들고
* 🛠 그 컬렉션들을 조합하여 → **추상 자료형(도구/구조)**을 구성하며
* 🔄 그 위에서 → **알고리즘**이 작동합니다!

### ✅ 그림으로 이해하기

```
[ 일반 자료형 ]     →     [ 컬렉션 자료형 ]       →     [ 추상 자료형 ]         →        [ 알고리즘 ]
 (숫자, 문자 등)         (리스트, 맵 등)              (스택, 트리, 그래프 등)         (정렬, 탐색 등)

     재료                재료를 담는 틀                문제 해결용 구조               요리 방법
```

---

## 3. 결론

- ✔️ **추상 자료형**은 개념이자 알고리즘의 기반 구조입니다.
- ✔️ 실제로는 **일반 자료형**과 **컬렉션 자료형**을 적절히 조합하여 구현됩니다.
- ✔️ 따라서 대부분의 프로그래밍 언어에서 `Stack`, `Queue`, `Tree` 등을 직접 구현하거나 라이브러리 형태로 제공하는 이유가 여기에 있습니다.

---

# B.알고리즘: 문제 해결을 위한 요리법


- 알고리즘은 특정 문제를 해결하기 위한 일련의 잘 정의된 절차나 규칙입니다. 
- 아래에서는 거의 모든 프로그래밍 문제 해결에 사용되는 대표적인 알고리즘 유형들을 설명합니다.

---

## 1. 알고리즘의 주요 분류

| 분류           | 핵심 개념                          | 대표 예시                            |
| :------------- | :--------------------------------- | :----------------------------------- |
| **정렬 (Sorting)** | 데이터의 순서를 특정 기준에 따라 정리 | 버블 정렬, 선택 정렬, 병합 정렬, 퀵 정렬 등 |
| **탐색 (Searching)** | 원하는 데이터를 찾아냄               | 선형 탐색, 이진 탐색                 |
| **재귀 (Recursion)** | 함수가 자기 자신을 호출하는 방식     | 하노이탑, 피보나치 수열              |
| **분할 정복 (Divide & Conquer)** | 큰 문제를 작은 조각으로 나누어 해결 후 결합 | 병합 정렬, 퀵 정렬                   |
| **탐욕법 (Greedy)** | 매 순간 최선의 선택을 하여 최종 답 도출 | 거스름돈 문제, Kruskal 알고리즘      |
| **동적 계획법 (Dynamic Programming, DP)** | 중복되는 계산을 저장하고 재사용하여 효율성 증대 | 피보나치 수열, 배낭 문제             |
| **백트래킹 (Backtracking)** | 모든 경우의 수를 탐색하며, 조건 불충족 시 되돌아가 다른 경로 탐색 | 미로 찾기, N-Queen 문제              |
| **그래프 알고리즘** | 연결 관계(정점과 간선)를 다루는 문제 해결 | BFS, DFS, 다익스트라, 플로이드        |
| **트리 알고리즘** | 계층적 데이터 구조(트리)를 탐색하고 조작 | 이진 탐색 트리, 힙 정렬, 세그먼트 트리 |
| **정수론 / 수학** | 수학적 성질을 활용한 계산 최적화     | 유클리드 호제법, 소수 판별           |
| **문자열 알고리즘** | 텍스트 데이터를 분석하고 처리        | KMP 알고리즘, 라빈-카프 알고리즘     |

---

## 2. 주요 알고리즘 유형 상세 설명

### 🔢 2.1. 정렬 (Sorting)

데이터를 크기나 다른 기준에 따라 오름차순 또는 내림차순으로 재배열합니다.
* **대표 알고리즘:** 버블 정렬(Bubble Sort), 선택 정렬(Selection Sort), 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort)
* **쓰임:** 랭킹 정렬, 가격 순 정렬, 데이터베이스 결과 정렬

### 🔍 2.2. 탐색 (Searching)

특정 조건을 만족하는 데이터를 데이터 구조 내에서 찾아냅니다.
* **대표 알고리즘:** 선형 탐색(Linear Search), 이진 탐색(Binary Search)
* **쓰임:** 사전에서 단어 찾기, 리스트에서 특정 값 찾기

### 🔁 2.3. 재귀 (Recursion)

함수가 자기 자신을 호출하는 프로그래밍 기법입니다. 문제를 더 작은 동일한 문제로 나누어 해결할 때 유용합니다.
* **예시:** 팩토리얼 계산, 피보나치 수열, 트리 순회

### 🪓 2.4. 분할 정복 (Divide and Conquer)

주어진 문제를 여러 개의 작은 하위 문제로 분할하고(Divide), 각 하위 문제를 해결한 뒤(Conquer), 그 해답들을 결합하여 원래 문제의 해답을 얻는(Combine) 방식입니다.
* **예시:** 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort)

### 💰 2.5. 탐욕 알고리즘 (Greedy)

매 순간 현재 상황에서 가장 최적이라고 판단되는 선택을 하는 방식입니다. 항상 전체적인 최적해를 보장하지는 않지만, 특정 문제에서는 최적의 해를 찾아낼 수 있습니다.
* **예시:** 동전 교환 문제, 최소 스패닝 트리 (Kruskal)

### 📦 2.6. 동적 계획법 (Dynamic Programming, DP)

복잡한 문제를 여러 개의 단순한 하위 문제로 나누어 해결하되, 이전에 계산했던 하위 문제의 결과를 저장하고 재사용하여 효율성을 높이는 방법입니다. 중복 계산을 피하는 것이 핵심입니다.
* **예시:** 피보나치 수열, 배낭 문제 (Knapsack Problem)

### 🧩 2.7. 백트래킹 (Backtracking)

해를 찾아가는 도중에 해가 될 가능성이 없는 경로를 발견하면 즉시 되돌아가(백트랙) 다른 경로를 탐색하는 방법입니다. 모든 가능한 경우의 수를 체계적으로 탐색할 때 사용됩니다.
* **예시:** N-Queen 문제, 미로 찾기, 암호 조합 찾기

### 🕸 2.8. 그래프 알고리즘

정점(Vertex)과 간선(Edge)으로 이루어진 **그래프** 자료구조를 활용하여 문제를 해결합니다. 최단 경로, 최소 신장 트리, 연결성 분석 등 다양한 문제에 적용됩니다.
* **대표 알고리즘:** BFS(너비 우선 탐색), DFS(깊이 우선 탐색), 다익스트라(Dijkstra), 플로이드-워셜(Floyd-Warshall) (최단 경로), Kruskal, Prim (최소 신장 트리)

### 🌲 2.9. 트리 기반 알고리즘

계층적인 데이터 구조인 **트리**를 효율적으로 탐색하고 조작하는 알고리즘입니다.
* **대표 알고리즘:** 힙 정렬(Heap Sort), 이진 탐색 트리(Binary Search Tree) 관련 연산, 세그먼트 트리(Segment Tree)

### 🔢 2.10. 수학 / 정수론 알고리즘

수학적 성질, 특히 정수론(Integers Theory)의 개념을 이용하여 문제 해결의 효율을 높이는 알고리즘입니다.
* **대표 알고리즘:** 최대공약수(GCD), 소수 판별, 에라토스테네스의 체

---

## 3. 상황별 알고리즘 선택 예시

어떤 문제를 해결해야 할지에 따라 적합한 알고리즘 유형이 달라집니다.

| 상황                           | 적합한 알고리즘              |
| :----------------------------- | :--------------------------- |
| 데이터를 특정 순서로 나열해야 해요 | **Merge Sort**, **Quick Sort** |
| 두 지점 간의 최단 거리를 찾아야 해요 | **Dijkstra**, **BFS** |
| 가능한 모든 경우의 조합을 찾아야 해요 | **Backtracking**, **DFS** |
| 매 순간 가장 이득이 되는 선택을 해야 해요 | **Greedy** |
| 중복 계산을 피하면서 최적해를 찾아야 해요 | **Dynamic Programming** |
| 큰 문제를 작은 문제로 나누어 해결하고 싶어요 | **Divide & Conquer** |

---

## 4. 실전에서의 알고리즘 조합

실제 문제 해결에서는 여러 알고리즘 유형이 조합되어 사용되는 경우가 많습니다.

```python
# "사용자 점수 중 80점 이상만 이름 순으로 정렬"

users = [
  {"name": "Alice", "score": 95},
  {"name": "Bob", "score": 70},
  {"name": "Charlie", "score": 88},
  {"name": "David", "score": 80}
]

# 1. 조건으로 필터링 (탐색 알고리즘의 개념)
#   - 리스트를 순회하며 조건을 만족하는 요소를 찾음
filtered_users = [user for user in users if user["score"] >= 80]
# 결과: [{'name': 'Alice', 'score': 95}, {'name': 'Charlie', 'score': 88}, {'name': 'David', 'score': 80}]

# 2. 이름 순으로 정렬 (정렬 알고리즘 기반)
#   - 필터링된 사용자 목록을 이름(key='name')을 기준으로 정렬
sorted_users = sorted(filtered_users, key=lambda user: user["name"])
# 결과: [{'name': 'Alice', 'score': 95}, {'name': 'Charlie', 'score': 88}, {'name': 'David', 'score': 80}]
```

---

## 5. 결론

프로그래밍에서 데이터를 다루는 전체적인 흐름은 다음과 같이 비유할 수 있습니다.

* **자료형** = **재료**
* **컬렉션 / 추상 자료형** = **도구 / 그릇**
* **알고리즘** = **문제 해결 방법 (요리법)**

---