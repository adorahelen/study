

# ìë°” ìŠ¤ë ˆë“œ 


---

#### âœ… 1. ë™ê¸°(Synchronous) vs ë¹„ë™ê¸°(Asynchronous)ì˜ ì •í™•í•œ ì˜ë¯¸

* **ë™ê¸°(Synchronous):**
    * ì‘ì—…ì´ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.
    * í•˜ë‚˜ì˜ ì‘ì—…ì´ ì™„ë£Œë˜ì–´ì•¼ë§Œ ë‹¤ìŒ ì‘ì—…ì´ ì‹œì‘ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    * ì˜ˆ: í•¨ìˆ˜ í˜¸ì¶œ í›„ ê²°ê³¼ê°€ ë°˜í™˜ë  ë•Œê¹Œì§€ ëŒ€ê¸°.
* **ë¹„ë™ê¸°(Asynchronous):**
    * ì‘ì—…ì´ ë™ì‹œì—(í˜¹ì€ ë³‘ë ¬ì ìœ¼ë¡œ) ì‹¤í–‰ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    * í˜„ì¬ ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë‹¤ìŒ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    * ì˜ˆ: ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ ë³´ë‚´ê³  ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ë‹¤ë¥¸ ì‘ì—…ì„ ìˆ˜í–‰.

#### âœ… 2. ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì˜ ë¬¸ì œ

ê³µìœ  ìì› ì ‘ê·¼ ì‹œ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* **Race Condition (ê²½ìŸ ìƒíƒœ):**
    * ë‘ ê°œ ì´ìƒì˜ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê³µìœ  ë³€ìˆ˜ë‚˜ ìì›ì— ì ‘ê·¼í•˜ì—¬ ìµœì¢… ê²°ê³¼ê°€ ì ‘ê·¼ ìˆœì„œì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ìƒí™©ì…ë‹ˆë‹¤.
    * ê²°ê³¼ë¥¼ ì˜ˆì¸¡í•˜ê¸° ì–´ë µê²Œ ë§Œë“­ë‹ˆë‹¤.
* **Deadlock (êµì°© ìƒíƒœ):**
    * ë‘ ìŠ¤ë ˆë“œ(ì´ìƒ)ê°€ ì„œë¡œê°€ ì ìœ í•˜ê³  ìˆëŠ” ìì›ì„ ì–»ê¸° ìœ„í•´ ì˜ì›íˆ ëŒ€ê¸°í•˜ëŠ” ìƒíƒœì…ë‹ˆë‹¤.
    * ì‹œìŠ¤í…œì´ ë©ˆì¶˜ ê²ƒì²˜ëŸ¼ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
* **Starvation (ê¸°ì•„ ìƒíƒœ):**
    * íŠ¹ì • ìŠ¤ë ˆë“œê°€ ìì›ì„ ê³„ì†í•´ì„œ ì–»ì§€ ëª»í•˜ê³  ì‘ì—…ì„ ìˆ˜í–‰í•˜ì§€ ëª»í•˜ëŠ” ìƒíƒœì…ë‹ˆë‹¤.
    * ìš°ì„ ìˆœìœ„ê°€ ë‚®ì€ ìŠ¤ë ˆë“œê°€ ìì£¼ ê²ªì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
* **Livelock (í™œë™ì„± ìƒíƒœ):**
    * ë°ë“œë½ê³¼ ë¹„ìŠ·í•˜ê²Œ ì‘ì—…ì„ ì§„í–‰í•˜ì§€ ëª»í•˜ì§€ë§Œ, ìŠ¤ë ˆë“œë“¤ì´ ì„œë¡œì˜ ìƒíƒœ ë³€í™”ì— ë°˜ì‘í•˜ë©° ê³„ì†í•´ì„œ ìƒíƒœë¥¼ ë°”ê¾¸ëŠ” ìƒí™©ì…ë‹ˆë‹¤. (ì˜ˆ: ì„œë¡œ ë¹„ì¼œì£¼ë ¤ë‹¤ê°€ ê³„ì† ê°™ì€ ìë¦¬ì—ì„œ ë¶€ë”ªíˆëŠ” ê²½ìš°)

#### âœ… 3. ë™ê¸°í™” (Synchronized í‚¤ì›Œë“œ)

ìë°”ì—ì„œ ê³µìœ  ìì› ì ‘ê·¼ì„ ì œì–´í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ë°©ë²•ì…ë‹ˆë‹¤.

* **Method-level ë™ê¸°í™”:**
    * `public synchronized void methodName() { /* ... */ }`
    * í•´ë‹¹ ë©”ì„œë“œê°€ ì†í•œ ê°ì²´ì˜ Lockì„ íšë“í•©ë‹ˆë‹¤. (ì •ì  ë©”ì„œë“œì˜ ê²½ìš° í´ë˜ìŠ¤ Lock)
    * í•œ ë²ˆì— í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë§Œ í•´ë‹¹ ë©”ì„œë“œë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
* **Block-level ë™ê¸°í™”:**
    * `synchronized(obj) { /* critical section */ }`
    * `obj` ê°ì²´ì˜ Lockì„ íšë“í•˜ë©°, ì¤‘ê´„í˜¸ `{}` ì•ˆì˜ ì½”ë“œ ë¸”ë¡(critical section)ë§Œ ë³´í˜¸í•©ë‹ˆë‹¤.
    * ë©”ì„œë“œ ì „ì²´ë³´ë‹¤ ë” ì„¸ë°€í•œ ì œì–´ê°€ ê°€ëŠ¥í•˜ì—¬ ì„±ëŠ¥ìƒ ì´ì ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
* **ì¥ì :** ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤.
* **ë‹¨ì :** ê³¼ë„í•œ ì‚¬ìš©ì€ ì„±ëŠ¥ ì €í•˜(ë³‘ëª© í˜„ìƒ)ë¥¼ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

#### âœ… 4. `java.util.concurrent` íŒ¨í‚¤ì§€ (Java ë™ì‹œì„± API)

ì‹¤ë¬´ì—ì„œëŠ” `synchronized` í‚¤ì›Œë“œë³´ë‹¤ ë” ìœ ì—°í•˜ê³  ê³ ì„±ëŠ¥ì˜ ë™ì‹œì„± API ì‚¬ìš©ì„ ì„ í˜¸í•˜ëŠ” ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.

* **`Lock` ì¸í„°í˜ì´ìŠ¤ (ReentrantLock, ReadWriteLock ë“±):**
    * `synchronized` ë¸”ë¡ë³´ë‹¤ ë” ìœ ì—°í•œ Lock ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µí•©ë‹ˆë‹¤. (ì˜ˆ: Lock íšë“ ì‹œë„, íƒ€ì„ì•„ì›ƒ ì„¤ì •, interruptible Lock)
    * `ReentrantLock`: ì¬ì§„ì… ê°€ëŠ¥í•œ ìƒí˜¸ ë°°ì œ Lock.
    * `ReadWriteLock`: ì½ê¸° ìŠ¤ë ˆë“œëŠ” ì—¬ëŸ¬ ê°œ í—ˆìš©í•˜ê³  ì“°ê¸° ìŠ¤ë ˆë“œëŠ” í•œ ë²ˆì— í•˜ë‚˜ë§Œ í—ˆìš©í•˜ì—¬ ì½ê¸° ì‘ì—…ì´ ë§ì€ ê²½ìš° ì„±ëŠ¥ í–¥ìƒì— ìœ ë¦¬í•©ë‹ˆë‹¤.
* **Executor í”„ë ˆì„ì›Œí¬ (ExecutorService, ThreadPoolExecutor):**
    * ìŠ¤ë ˆë“œ ìƒì„± ë° ê´€ë¦¬ì˜ ë³µì¡ì„±ì„ ì¶”ìƒí™”í•˜ì—¬ ê°œë°œìê°€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ì§‘ì¤‘í•  ìˆ˜ ìˆê²Œ ë•ìŠµë‹ˆë‹¤.
    * `ThreadPoolExecutor`: ê³ ì •ëœ ìˆ˜ì˜ ìŠ¤ë ˆë“œë¥¼ ì¬ì‚¬ìš©í•˜ì—¬ ìŠ¤ë ˆë“œ ìƒì„± ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì…ë‹ˆë‹¤.
* **Future, Callable, CompletableFuture:**
    * ë¹„ë™ê¸° ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ë‚˜íƒ€ë‚´ê±°ë‚˜, ë¹„ë™ê¸° ì‘ì—…ì„ ì¡°í•©í•˜ê³  ê²°ê³¼ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
    * `Callable`: `Runnable`ê³¼ ìœ ì‚¬í•˜ë‚˜ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³  ì˜ˆì™¸ë¥¼ ë˜ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    * `Future`: `Callable`ì˜ ì‹¤í–‰ ê²°ê³¼ë¥¼ ì–»ì–´ì˜¤ê±°ë‚˜ ì‘ì—…ì˜ ì™„ë£Œ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
    * `CompletableFuture`: Java 8ì—ì„œ ë„ì…ëœ ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°ì˜ ê°•ë ¥í•œ ë„êµ¬ë¡œ, ì—¬ëŸ¬ ë¹„ë™ê¸° ì‘ì—…ì„ ì‰½ê²Œ ì¡°í•©í•˜ê³  ë³€í™˜í•˜ë©° ì—ëŸ¬ë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.
* **Atomic ë³€ìˆ˜ (AtomicInteger, AtomicLong, AtomicBoolean ë“±):**
    * CAS(Compare-And-Swap) ì—°ì‚°ì„ ì‚¬ìš©í•˜ì—¬ Lock ì—†ì´ ìŠ¤ë ˆë“œ ì•ˆì „í•œ ì›ìì (atomic) ì—°ì‚°ì„ ì œê³µí•©ë‹ˆë‹¤.
    * `synchronized`ë³´ë‹¤ ì„±ëŠ¥ìƒ ì´ì ì´ ìˆìŠµë‹ˆë‹¤.
* **ìŠ¤ë ˆë“œ ì•ˆì „ ì»¬ë ‰ì…˜ (ConcurrentHashMap, CopyOnWriteArrayList ë“±):**
    * ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì•ˆì „í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„¤ê³„ëœ ì»¬ë ‰ì…˜ì…ë‹ˆë‹¤.
    * `ConcurrentHashMap`: ì¼ë°˜ `HashMap`ë³´ë‹¤ ë™ì‹œì„± ì²˜ë¦¬ ì„±ëŠ¥ì´ ìš°ìˆ˜í•©ë‹ˆë‹¤.

#### âœ… 5. ë¹„ë™ê¸° ì²˜ë¦¬ ë°©ì‹ì˜ êµ¬í˜„

* **ì „í†µì  ë°©ë²•:**
    * `Runnable` ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
    * `Thread` í´ë˜ìŠ¤ ì§ì ‘ ì‚¬ìš© (ì¼ë°˜ì ìœ¼ë¡œ `Executor` í”„ë ˆì„ì›Œí¬ ì‚¬ìš©ì„ ê¶Œì¥)
    * `Executor` í”„ë ˆì„ì›Œí¬ë¥¼ ì´ìš©í•œ ìŠ¤ë ˆë“œ í’€ ê´€ë¦¬
* **í˜„ëŒ€ì  ë°©ë²•:**
    * **`CompletableFuture`:**
        * ë¹„ë™ê¸° ì—°ì‚°ì„ ì¡°í•©í•˜ê³  íŒŒì´í”„ë¼ì¸ì„ êµ¬ì¶•í•˜ëŠ” ë° ë§¤ìš° íš¨ê³¼ì ì…ë‹ˆë‹¤.
        * `thenApply()`, `thenAccept()`, `thenCompose()`, ``allOf()`, `anyOf()` ë“±ì˜ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ë¹„ë™ê¸° íë¦„ ì œì–´ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
    * **Reactive Programming (ë¦¬ì•¡í‹°ë¸Œ í”„ë¡œê·¸ë˜ë°):**
        * Project Reactor (Spring WebFlux í¬í•¨), RxJava ë“±ì˜ í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
        * ë°ì´í„° ìŠ¤íŠ¸ë¦¼ê³¼ ë¹„ë™ê¸° ì´ë²¤íŠ¸ë¥¼ ë‹¤ë£¨ëŠ” ë° íŠ¹í™”ë˜ì–´ ìˆìœ¼ë©°, ë…¼ë¸”ë¡œí‚¹(Non-blocking) ë° ì´ë²¤íŠ¸ ê¸°ë°˜ ì• í”Œë¦¬ì¼€ì´ì…˜ ê°œë°œì— ì í•©í•©ë‹ˆë‹¤.

#### âœ… 6. ì‹¤ì „ ì ìš© ì‹œ ì£¼ì˜í•  ì 

* **ìŠ¤ë ˆë“œ ìˆ˜ ê´€ë¦¬ (Thread pool ì‚¬ìš©):**
    * ë¬´ë¶„ë³„í•œ ìŠ¤ë ˆë“œ ìƒì„±ì€ ì‹œìŠ¤í…œ ìì› ê³ ê°ˆê³¼ ì„±ëŠ¥ ì €í•˜ë¥¼ ìœ ë°œí•©ë‹ˆë‹¤.
    * `ThreadPoolExecutor` ë“±ì„ ì‚¬ìš©í•˜ì—¬ ì ì ˆí•œ ìŠ¤ë ˆë“œ í’€ í¬ê¸°ë¥¼ ìœ ì§€í•´ì•¼ í•©ë‹ˆë‹¤.
* **ìì› ê´€ë¦¬ (ë™ê¸°í™” ë˜ëŠ” ë½):**
    * ê³µìœ  ìì›ì— ëŒ€í•œ ì ‘ê·¼ì€ ë°˜ë“œì‹œ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì„ í†µí•´ ë³´í˜¸í•´ì•¼ í•©ë‹ˆë‹¤.
    * `synchronized`, `Lock`, `Atomic` ë³€ìˆ˜, `Concurrent` ì»¬ë ‰ì…˜ ë“± ìƒí™©ì— ë§ëŠ” ìµœì ì˜ ë„êµ¬ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.
* **íƒ€ì„ì•„ì›ƒ ë° ì˜ˆì™¸ ì²˜ë¦¬:**
    * ë¹„ë™ê¸° ì‘ì—…ì´ë‚˜ Lock íšë“ ì‹œ ë¬´í•œ ëŒ€ê¸°ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ íƒ€ì„ì•„ì›ƒì„ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤.
    * ê° ìŠ¤ë ˆë“œì—ì„œ ë°œìƒí•˜ëŠ” ì˜ˆì™¸ë¥¼ ì ì ˆíˆ ì²˜ë¦¬í•˜ê³  ì „íŒŒí•´ì•¼ í•©ë‹ˆë‹¤.
* **ë¹„ë™ê¸° ê²°ê³¼ì˜ ì²˜ë¦¬ ìˆœì„œ ë³´ì¥ ì—¬ë¶€:**
    * ë¹„ë™ê¸° ì‘ì—…ì˜ ì™„ë£Œ ìˆœì„œëŠ” ë³´ì¥ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìˆœì„œê°€ ì¤‘ìš”í•œ ê²½ìš° `CompletableFuture.thenCompose()`ë‚˜ ë‹¤ë¥¸ ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜ì„ í†µí•´ ìˆœì„œë¥¼ ì œì–´í•´ì•¼ í•©ë‹ˆë‹¤.

---

### ğŸ’¡ ì¶”ê°€ì ìœ¼ë¡œ ë” ì•Œì•„ì•¼ í•  ë‚´ìš©

ìœ„ ë‚´ìš© ì™¸ì—ë„ ìë°” ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì„ ë” ê¹Šì´ ì´í•´í•˜ê³  ì‹¤ì „ì— ì ìš©í•˜ëŠ” ë° ë„ì›€ì´ ë˜ëŠ” ëª‡ ê°€ì§€ ê°œë…ì´ ìˆìŠµë‹ˆë‹¤.

* **`volatile` í‚¤ì›Œë“œ:**
    * ë³€ìˆ˜ì˜ ê°€ì‹œì„±(Visibility)ì„ ë³´ì¥í•©ë‹ˆë‹¤. ì¦‰, í•œ ìŠ¤ë ˆë“œì—ì„œ `volatile` ë³€ìˆ˜ì˜ ë³€ê²½ì´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ì¦‰ì‹œ ë³´ì¥ë˜ë„ë¡ í•©ë‹ˆë‹¤.
    * `synchronized`ë‚˜ `Lock`ê³¼ëŠ” ë‹¬ë¦¬ ì›ìì„±(Atomicity)ì€ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë‹¨ìˆœí•œ í”Œë˜ê·¸ ë³€ìˆ˜ë‚˜ ìƒíƒœ ë³€ê²½ì— ìœ ìš©í•©ë‹ˆë‹¤.
* **`ThreadLocal` í´ë˜ìŠ¤:**
    * ìŠ¤ë ˆë“œ ë¡œì»¬ ë³€ìˆ˜ë¥¼ ìƒì„±í•˜ì—¬ ê° ìŠ¤ë ˆë“œê°€ ìì‹ ë§Œì˜ ë…ë¦½ì ì¸ ë³€ìˆ˜ ë³µì‚¬ë³¸ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
    * ê³µìœ  ìì›ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„ ìŠ¤ë ˆë“œ ê°„ì˜ ë°ì´í„° ê²©ë¦¬ë¥¼ í†µí•´ Race Conditionì„ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì˜ˆ: ì‚¬ìš©ì ì„¸ì…˜ ì •ë³´, íŠ¸ëœì­ì…˜ ID ë“±)
* **ë™ì‹œì„± ì„¤ê³„ íŒ¨í„´ ë° ì›ì¹™:**
    * Immutable Objects (ë¶ˆë³€ ê°ì²´): ê°ì²´ ìƒì„± í›„ ìƒíƒœë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ê²Œ í•˜ì—¬ ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì„ ë†’ì´ëŠ” ë°©ë²•.
    * Guarded Suspension (ë³´í˜¸ëœ ì¼ì‹œ ì¤‘ë‹¨): íŠ¹ì • ì¡°ê±´ì´ ì¶©ì¡±ë  ë•Œê¹Œì§€ ìŠ¤ë ˆë“œë¥¼ ì¼ì‹œ ì¤‘ë‹¨ì‹œí‚¤ëŠ” íŒ¨í„´.
    * Producer-Consumer Pattern (ìƒì‚°ì-ì†Œë¹„ì íŒ¨í„´): ì‘ì—…ì„ ìƒì„±í•˜ëŠ” ìŠ¤ë ˆë“œì™€ ì†Œë¹„í•˜ëŠ” ìŠ¤ë ˆë“œë¥¼ ë¶„ë¦¬í•˜ì—¬ íš¨ìœ¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” íŒ¨í„´.
* **ë™ì‹œì„± ì½”ë“œ í…ŒìŠ¤íŠ¸:**
    * ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì˜ ì½”ë“œëŠ” í…ŒìŠ¤íŠ¸í•˜ê¸° ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤.
    * ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ Race Condition ë“±ì„ ì¡ì•„ë‚´ê¸° ìœ„í•œ íŠ¹ë³„í•œ í…ŒìŠ¤íŠ¸ ì „ëµê³¼ ë„êµ¬(ì˜ˆ: JCStress)ê°€ í•„ìš”í•©ë‹ˆë‹¤.
* **JDK 21+ Structured Concurrency (êµ¬ì¡°ì  ë™ì‹œì„±):** (ë¯¸ë˜ ì§€í–¥ì )
    * ë³µì¡í•œ ë™ì‹œì„± ì‘ì—…ì„ êµ¬ì¡°í™”ëœ ë°©ì‹ìœ¼ë¡œ ì‘ì„±í•˜ê³  ê´€ë¦¬í•˜ëŠ” ìƒˆë¡œìš´ ì ‘ê·¼ ë°©ì‹ì…ë‹ˆë‹¤.
    * ë™ì‹œì„± ì‘ì—…ì˜ ë¼ì´í”„ì‚¬ì´í´ì„ ë” ì‰½ê²Œ ê´€ë¦¬í•˜ê³  ì—ëŸ¬ ì²˜ë¦¬ë¥¼ ê°„ì†Œí™”í•©ë‹ˆë‹¤. (í˜„ ì‹œì ì—ì„œëŠ” ì„ íƒì  í•™ìŠµ)

---



---

## Concurrent ë¼ì´ë¸ŒëŸ¬ë¦¬ ë‚´ë¶€ ì¸í„°í˜ì´ìŠ¤ ì°¨ì´ 

 `Executor`ì™€ `ExecutorService`ëŠ” ëª¨ë‘ ìŠ¤ë ˆë“œì—ì„œ ì‘ì—…ì„ ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í•µì‹¬ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤. ì´ ë‘˜ì€ ê³„ì¸µ ê´€ê³„ì— ìˆìœ¼ë©°, `ExecutorService`ê°€ `Executor`ë¥¼ í™•ì¥í•˜ì—¬ ë” ë§ì€ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

### 1. `Executor` ì¸í„°í˜ì´ìŠ¤

`Executor`ëŠ” ìŠ¤ë ˆë“œ ì‹¤í–‰ì„ ìœ„í•œ ê°€ì¥ ê¸°ë³¸ì ì¸ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
* **ë‹¨ì¼ ë©”ì„œë“œ:** `void execute(Runnable command)`ë§Œì„ ê°€ì§‘ë‹ˆë‹¤.
* **ì—­í• :** ì‘ì—… ì œì¶œ(task submission)ê³¼ ì‘ì—… ì‹¤í–‰(task execution)ì˜ ë©”ì»¤ë‹ˆì¦˜ì„ ë¶„ë¦¬í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤. ì¦‰, `execute()` ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ëŠ” ìª½ì—ì„œëŠ” ì‹¤ì œ ì‘ì—…ì´ ì–´ë–¤ ìŠ¤ë ˆë“œì—ì„œ, ì–¸ì œ, ì–´ë–»ê²Œ ì‹¤í–‰ë ì§€ì— ëŒ€í•´ ì „í˜€ ì•Œ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤. êµ¬í˜„ì²´ì— ë”°ë¼ ìƒˆë¡œìš´ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ ìˆ˜ë„, ê¸°ì¡´ ìŠ¤ë ˆë“œ í’€ì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
* **ë°˜í™˜ ê°’/ì˜ˆì™¸:** `Runnable`ë§Œì„ ë°›ê¸° ë•Œë¬¸ì— ì‘ì—…ì„ ì‹¤í–‰í•œ ê²°ê³¼ë¥¼ ë°˜í™˜ë°›ì„ ìˆ˜ ì—†ê³ , ì²´í¬ë“œ ì˜ˆì™¸ë„ ì™¸ë¶€ë¡œ ë˜ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
* **ìƒëª…ì£¼ê¸° ê´€ë¦¬ ì—†ìŒ:** `Executor` ì¸í„°í˜ì´ìŠ¤ ìì²´ëŠ” ìŠ¤ë ˆë“œ í’€ì˜ ì‹œì‘, ì¢…ë£Œ, í˜„ì¬ ìƒíƒœ í™•ì¸ ë“±ê³¼ ê°™ì€ ìƒëª…ì£¼ê¸° ê´€ë¦¬ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

**ê°„ë‹¨í•œ ì‚¬ìš© ì˜ˆì‹œ:**
```java
import java.util.concurrent.Executor;

class MyTask implements Runnable {
    private String name;
    public MyTask(String name) { this.name = name; }
    @Override
    public void run() {
        System.out.println("Executing " + name + " by " + Thread.currentThread().getName());
    }
}

public class ExecutorExample {
    public static void main(String[] args) {
        // Executor êµ¬í˜„ì²´ (ëŒë‹¤ í‘œí˜„ì‹ìœ¼ë¡œ ê°„ë‹¨í•˜ê²Œ)
        Executor executor = command -> new Thread(command).start(); // ìƒˆ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ì–´ì„œ ì‹¤í–‰

        executor.execute(new MyTask("Task 1"));
        executor.execute(new MyTask("Task 2"));
    }
}
```

### 2. `ExecutorService` ì¸í„°í˜ì´ìŠ¤

`ExecutorService`ëŠ” `Executor` ì¸í„°í˜ì´ìŠ¤ë¥¼ í™•ì¥í•œ(extends) ì¸í„°í˜ì´ìŠ¤ë¡œ, `Executor`ì˜ ê¸°ëŠ¥ì— ë”í•´ ìŠ¤ë ˆë“œ í’€ì˜ **ìƒëª…ì£¼ê¸° ê´€ë¦¬** ë° **ë¹„ë™ê¸° ì‘ì—…ì˜ ê²°ê³¼ ë° ìƒíƒœ ê´€ë¦¬** ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.

* **í™•ì¥ëœ ê¸°ëŠ¥:**
  * **ì‘ì—… ì œì¶œ ë° ê²°ê³¼ ë°˜í™˜:**
    * `Future<?> submit(Runnable task)`: `Runnable` ì‘ì—…ì„ ì œì¶œí•˜ê³  `Future` ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `Future`ëŠ” ì‘ì—…ì˜ ì™„ë£Œ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    * `<T> Future<T> submit(Callable<T> task)`: `Callable` ì‘ì—…ì„ ì œì¶œí•˜ê³  `Future` ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. `Callable`ì€ ê°’ì„ ë°˜í™˜í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, `Future`ë¥¼ í†µí•´ ê·¸ ê°’ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  * **ìŠ¤ë ˆë“œ í’€ ìƒëª…ì£¼ê¸° ê´€ë¦¬:**
    * `void shutdown()`: í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ ìŠ¤ë ˆë“œ í’€ì„ ìš°ì•„í•˜ê²Œ ì¢…ë£Œí•©ë‹ˆë‹¤. ìƒˆë¡œìš´ ì‘ì—…ì„ ë” ì´ìƒ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.
    * `List<Runnable> shutdownNow()`: ì¦‰ì‹œ ìŠ¤ë ˆë“œ í’€ì„ ì¢…ë£Œí•˜ë ¤ê³  ì‹œë„í•©ë‹ˆë‹¤. ì‹¤í–‰ ì¤‘ì¸ ì‘ì—…ì„ ì¸í„°ëŸ½íŠ¸í•˜ê³ , ëŒ€ê¸° ì¤‘ì¸ ì‘ì—…ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    * `boolean isShutdown()`: ìŠ¤ë ˆë“œ í’€ì´ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
    * `boolean isTerminated()`: `shutdown()` ë˜ëŠ” `shutdownNow()` í˜¸ì¶œ í›„ ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì–´ ìŠ¤ë ˆë“œ í’€ì´ ì™„ì „íˆ ì¢…ë£Œë˜ì—ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
    * `boolean awaitTermination(long timeout, TimeUnit unit)`: ìŠ¤ë ˆë“œ í’€ì´ ì§€ì •ëœ ì‹œê°„ ë‚´ì— ì¢…ë£Œë  ë•Œê¹Œì§€ í˜„ì¬ ìŠ¤ë ˆë“œë¥¼ ë¸”ë¡í•©ë‹ˆë‹¤.
  * **ë‹¤ì¤‘ ì‘ì—… ì œì¶œ:**
    * `<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)`: ì—¬ëŸ¬ `Callable` ì‘ì—…ì„ í•œ ë²ˆì— ì œì¶œí•˜ê³ , ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦° í›„ ê° ì‘ì—…ì˜ `Future` ëª©ë¡ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    * `<T> T invokeAny(Collection<? extends Callable<T>> tasks)`: ì—¬ëŸ¬ `Callable` ì‘ì—…ì„ ì œì¶œí•˜ê³ , ê·¸ ì¤‘ í•˜ë‚˜ë¼ë„ ì™„ë£Œë˜ë©´ í•´ë‹¹ ì‘ì—…ì˜ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ê³  ë‚˜ë¨¸ì§€ ì‘ì—…ì„ ì·¨ì†Œí•©ë‹ˆë‹¤.

**ì¼ë°˜ì ì¸ ì‚¬ìš© ì˜ˆì‹œ:**
```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // FixedThreadPool ìƒì„± (ExecutorServiceì˜ í•œ ì¢…ë¥˜)
        ExecutorService executorService = Executors.newFixedThreadPool(2);

        // 1. Runnable ì‘ì—… ì œì¶œ (Future ë°˜í™˜)
        Future<?> future1 = executorService.submit(new MyTask("Runnable Task"));
        System.out.println("Runnable Task submitted. Is Done? " + future1.isDone()); // false or true

        // 2. Callable ì‘ì—… ì œì¶œ (Future ë°˜í™˜ ë° ê²°ê³¼ íšë“)
        Callable<String> myCallable = () -> {
            System.out.println("Executing Callable Task by " + Thread.currentThread().getName());
            Thread.sleep(1500);
            return "Callable Task Result!";
        };
        Future<String> future2 = executorService.submit(myCallable);

        try {
            // Future.get()ì€ ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ë¸”ë¡í‚¹í•©ë‹ˆë‹¤.
            System.out.println("Waiting for Callable result...");
            String result = future2.get(); // ê²°ê³¼ ê°€ì ¸ì˜¤ê¸°
            System.out.println("Callable Task finished with result: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        // ìŠ¤ë ˆë“œ í’€ ì¢…ë£Œ (ìƒˆë¡œìš´ ì‘ì—…ì€ ë°›ì§€ ì•Šì§€ë§Œ, ì´ë¯¸ ì œì¶œëœ ì‘ì—…ì€ ì™„ë£Œ)
        executorService.shutdown();
        System.out.println("ExecutorService shutdown initiated.");

        // ëª¨ë“  ì‘ì—…ì´ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸°
        if (executorService.awaitTermination(5, TimeUnit.SECONDS)) {
            System.out.println("ExecutorService terminated.");
        } else {
            System.out.println("ExecutorService did not terminate in time, forcing shutdown.");
            executorService.shutdownNow();
        }
    }
}
```

### ìš”ì•½ ë¹„êµí‘œ

| íŠ¹ì§•         | `Executor`                                    | `ExecutorService`                                         |
| :----------- | :-------------------------------------------- | :-------------------------------------------------------- |
| **ìƒì† ê´€ê³„** | ê¸°ë³¸ ì¸í„°í˜ì´ìŠ¤                               | `Executor` ì¸í„°í˜ì´ìŠ¤ë¥¼ í™•ì¥                                  |
| **ë©”ì„œë“œ** | `void execute(Runnable command)`              | `execute()` ì™¸ì— `submit()`, `shutdown()`, `awaitTermination()`, `invokeAll()`, `invokeAny()` ë“± ì¶”ê°€ |
| **ì‘ì—… ì œì¶œ** | `Runnable`ë§Œ ê°€ëŠ¥                             | `Runnable`ê³¼ `Callable` ëª¨ë‘ ê°€ëŠ¥                          |
| **ê²°ê³¼ ë°˜í™˜** | ì—†ìŒ                                          | `submit()` ë©”ì„œë“œë¥¼ í†µí•´ `Future` ê°ì²´ ë°˜í™˜, ì‘ì—… ê²°ê³¼ íšë“ ê°€ëŠ¥ |
| **ì˜ˆì™¸ ì²˜ë¦¬** | ë‚´ë¶€ ì²˜ë¦¬ í•„ìš” (ë˜ì§ˆ ìˆ˜ ì—†ìŒ)                 | `Future.get()`ì„ í†µí•´ `ExecutionException`ìœ¼ë¡œ ì˜ˆì™¸ë¥¼ ì „ë‹¬ë°›ì•„ ì²˜ë¦¬ ê°€ëŠ¥ |
| **ìƒëª…ì£¼ê¸°** | ê´€ë¦¬ ê¸°ëŠ¥ ì—†ìŒ                                | `shutdown()`, `shutdownNow()`, `isTerminated()` ë“±ì„ í†µí•´ ìŠ¤ë ˆë“œ í’€ì˜ ì‹œì‘/ì¢…ë£Œ/ìƒíƒœ ê´€ë¦¬ ê°€ëŠ¥ |
| **ì£¼ìš” ìš©ë„** | ê°„ë‹¨í•œ ì‘ì—… ì‹¤í–‰ ë¶„ë¦¬ (ì¶”ìƒí™”)                | ë³µì¡í•œ ë¹„ë™ê¸° ì‘ì—… ê´€ë¦¬, ìŠ¤ë ˆë“œ í’€ì˜ ìƒëª…ì£¼ê¸° ì œì–´, ê²°ê³¼/ì˜ˆì™¸ ì²˜ë¦¬ í•„ìš” ì‹œ |

ê²°ë¡ ì ìœ¼ë¡œ, `Executor`ëŠ” ì‘ì—…ì„ ì‹¤í–‰í•˜ëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ê³„ì•½(contract)ì„ ì •ì˜í•˜ê³ , `ExecutorService`ëŠ” ê·¸ ê³„ì•½ì„ í™•ì¥í•˜ì—¬ ìŠ¤ë ˆë“œ í’€ì˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬ ë° ë¹„ë™ê¸° ì‘ì—…ì˜ ê²°ê³¼ ê´€ë¦¬ì— í•„ìš”í•œ ê°•ë ¥í•œ ê¸°ëŠ¥ë“¤ì„ ì¶”ê°€ ì œê³µí•©ë‹ˆë‹¤. ì‹¤ì œ ëŒ€ë¶€ë¶„ì˜ ë™ì‹œì„± í”„ë¡œê·¸ë˜ë°ì—ì„œëŠ” `Executor`ì˜ êµ¬í˜„ì²´ì´ì ë” ë§ì€ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” `ExecutorService`ë¥¼ ì£¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.