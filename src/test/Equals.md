`str1 == str2`가 `true`가 나오는 이유는 **자바의 문자열 상수 풀(String Constant Pool)** 때문입니다.

-----

### 문자열 상수 풀 이해하기

자바에서 문자열을 다룰 때는 두 가지 방식이 있습니다.

1.  **문자열 리터럴 (String Literal) 사용:**

    ```java
    String str1 = "Programming";
    String str2 = "Programming";
    ```

    이렇게 큰따옴표를 사용해서 문자열을 선언하면, JVM은 이 문자열들을 \*\*문자열 상수 풀(String Constant Pool)\*\*이라는 특별한 메모리 영역에 저장합니다. 이때, 이미 동일한 내용의 문자열이 풀에 존재한다면, 새로운 객체를 생성하지 않고 기존 객체의 참조값을 재사용합니다.

    * `str1 = "Programming"`을 선언할 때, "Programming"이라는 문자열이 풀에 없으면 새로 생성하고 `str1`이 이를 가리킵니다.
    * `str2 = "Programming"`을 선언할 때, JVM은 풀에 "Programming"이 이미 있음을 확인하고, 새로 만들지 않고 `str1`이 가리키던 **그 동일한 "Programming" 객체를 `str2`도 가리키게 합니다.**

    따라서 `str1`과 `str2`는 메모리상에서 \*\*동일한 주소(동일한 객체)\*\*를 참조하게 됩니다.

2.  **`new` 키워드를 사용한 String 객체 생성:**

    ```java
    String str3 = new String("Programming");
    ```

    `new` 키워드를 사용하면 문자열 상수 풀과는 별개로, **힙(Heap) 메모리 영역에 항상 새로운 String 객체를 생성합니다.** 설사 동일한 내용의 문자열이 풀이나 힙에 이미 존재하더라도, `new`를 쓰면 무조건 새 객체가 만들어집니다.

-----

### 코드 분석

이제 각 비교문이 왜 그런 결과를 내는지 살펴보죠.

* `println(str1 == str2)`

    * `str1`과 `str2`는 모두 문자열 리터럴 `"Programming"`을 사용했기 때문에, 자바의 문자열 상수 풀 덕분에 **같은 메모리 주소에 있는 동일한 String 객체를 참조**합니다.
    * `==` 연산자는 객체의 \*\*주소값(참조값)\*\*을 비교하므로, 같은 주소를 가리키는 `str1`과 `str2`의 비교는 \*\*`true`\*\*가 됩니다.

* `println(str1 == str3)`

    * `str1`은 문자열 상수 풀에 있는 `"Programming"` 객체를 참조합니다.
    * `str3`은 `new String()`을 통해 힙 메모리에 **새롭게 생성된** `"Programming"` 객체를 참조합니다.
    * 두 객체는 메모리상에서 다른 주소를 가지므로, `==` 연산자로 비교하면 \*\*`false`\*\*가 됩니다.

* `println(str1.equals(str3))`

    * `equals()` 메서드는 객체의 주소값이 아닌, \*\*문자열의 실제 내용(값)\*\*을 비교합니다.
    * `str1`과 `str3`는 비록 주소는 다르지만, 담고 있는 문자열 내용("Programming")은 동일합니다.
    * 따라서 `equals()` 메서드로 비교하면 \*\*`true`\*\*가 됩니다.

* `print(str2.equals(str3))`

    * 위와 같은 이유로 `str2`와 `str3` 역시 내용이 동일하므로 `equals()` 메서드로 비교하면 \*\*`true`\*\*가 됩니다.

-----

결론적으로, 첫 번째 `true`는 자바가 문자열 리터럴을 **문자열 상수 풀에서 재사용**하기 때문에 발생하는 현상입니다. 객체의 주소값을 비교할 때는 `==`를 사용하고, 내용(값)을 비교할 때는 `equals()` 메서드를 사용해야 한다는 것을 기억하는 것이 중요합니다.