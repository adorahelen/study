---

# Java 핵심 자료구조 / 멀티 스레드(비동기)

- Java Collections Framework는 데이터를 효율적으로 저장하고 관리할 수 있도록 다양한 자료구조 클래스와 인터페이스를 제공합니다. 
- 멀티스레딩은 작업자(Thread)에 관한 것이고, 비동기는 작업(Task)에 관한 것


---

### 1. `List` (순서 유지, 중복 허용)

요소가 추가된 순서를 유지하며, 동일한 요소를 여러 번 저장할 수 있습니다.

* **`ArrayList`**
    * **특징**: 내부적으로 **배열**을 사용하여 데이터를 저장합니다. 인덱스를 통한 **요소 접근(읽기)이 빠릅니다.** 하지만 리스트 중간에 요소를 추가하거나 삭제할 경우, 뒤의 요소들을 이동시켜야 하므로 성능 저하가 발생할 수 있습니다. 동기화되지 않습니다.
    * **주요 용도**: 요소의 **읽기 빈도가 높고**, 삽입/삭제가 적은 경우에 적합합니다.
* **`LinkedList`**
    * **특징**: 내부적으로 **이중 연결 리스트** 구조를 사용합니다. 따라서 요소의 **추가 및 삭제가 빈번할 때 효율적**입니다. 하지만 특정 인덱스의 요소를 찾기 위해선 처음부터 순회해야 하므로 접근(읽기) 속도는 `ArrayList`보다 느립니다. 동기화되지 않습니다.
    * **주요 용도**: 요소의 **잦은 삽입/삭제**가 필요한 경우, 또는 큐(Queue)나 스택(Stack)처럼 동작할 때 유용합니다.

---

### 2. `Set` (순서 유지 안 함, 중복 허용 안 함)

요소의 저장 순서가 보장되지 않으며, 중복된 요소를 허용하지 않습니다. 유일한 값들을 저장할 때 사용됩니다.

* **`HashSet`**
    * **특징**: **해싱(hashing) 메커니즘**을 사용하여 데이터를 저장합니다. 요소의 삽입, 삭제, 검색이 매우 빠릅니다. 요소의 저장 순서는 보장되지 않습니다. 동기화되지 않습니다.
    * **주요 용도**: **중복 없는 빠른 데이터 저장 및 검색**이 필요한 경우에 적합합니다.
* **`TreeSet`**
    * **특징**: 내부적으로 **트리(Red-Black Tree)** 구조를 사용하여 요소를 저장합니다. 요소들을 **자동으로 정렬된 상태로 유지**하며, 중복을 허용하지 않습니다. `HashSet`보다 삽입/삭제/검색 성능은 약간 느리지만, 정렬된 데이터를 쉽게 얻을 수 있습니다.
    * **주요 용도**: **정렬된 중복 없는 데이터**가 필요할 때 사용됩니다.

---

### 3. `Map` (키-값 쌍, 키 중복 허용 안 함)

키(Key)와 값(Value)의 쌍으로 데이터를 저장합니다. 키는 유일해야 하며, 값은 중복될 수 있습니다.

* **`HashMap`**
    * **특징**: **해싱(hashing) 메커니즘**을 사용하여 키-값 쌍을 저장합니다. 키와 값의 저장 순서는 보장되지 않습니다. **가장 많이 사용되는 `Map` 구현체**로, 키를 통한 값의 검색이 매우 빠릅니다. 동기화되지 않습니다.
    * **주요 용도**: **빠른 데이터 검색 및 조작**이 필요하며, 순서가 중요하지 않은 경우에 사용됩니다.
* **`TreeMap`**
    * **특징**: 내부적으로 **트리(Red-Black Tree)** 구조를 사용하여 키-값 쌍을 저장합니다. 키를 **자동으로 정렬된 상태로 유지**합니다. `HashMap`보다 삽입/삭제/검색 성능은 약간 느리지만, 키를 기준으로 정렬된 데이터를 얻을 수 있습니다.
    * **주요 용도**: **키를 기준으로 정렬된 Map**이 필요할 때 사용됩니다.

---

### 4. `Queue` 및 `Deque` (데이터 처리 순서 관리)

데이터를 특정 순서에 따라 처리해야 할 때 사용되는 인터페이스입니다.

* **`Queue`**
    * **특징**: **FIFO(First-In, First-Out)**, 즉 먼저 들어온 요소가 먼저 나가는 선입선출 구조입니다.
    * **대표 구현체**:
        * **`LinkedList`**: 큐로도 사용할 수 있으며, `offer()`, `poll()`, `peek()` 등의 메서드를 제공합니다.
        * **`PriorityQueue`**: 요소의 **우선순위**에 따라 정렬되어 저장되며, 가장 높은 우선순위의 요소가 먼저 제거됩니다. FIFO 순서를 보장하지 않습니다.
    * **주요 용도**: 작업 대기열, 메시지 큐 등 순차적인 처리가 필요한 경우.
* **`Deque` (Double Ended Queue)**
    * **특징**: 양쪽 끝에서 요소를 추가하거나 제거할 수 있는 큐(양방향 큐)입니다. 스택(LIFO)과 큐(FIFO)의 기능을 모두 수행할 수 있습니다.
    * **대표 구현체**:
        * **`ArrayDeque`**: 내부적으로 동적 배열을 사용하여 구현된 덱입니다. `LinkedList`나 구형 `Stack` 클래스보다 **성능이 좋은 경우가 많아** 스택이나 큐의 대체제로 권장됩니다.
    * **주요 용도**: 스택 및 큐의 유연한 구현, 너비 우선 탐색(BFS) 등.

---

### A. 멀티스레딩과 Java 자료구조: 효율성을 위한 고려사항

Java의 표준 자료구조(`ArrayList`, `HashMap` 등)는 **단일 스레드용**으로 설계되어 **스레드-세이프하지 않습니다.**

멀티스레딩 환경에서 이들을 직접 사용하면 **데이터 손상이나 예측 불가능한 오류**가 발생하며, 이는 비효율적인 결과를 초래합니다.

진정한 효율성을 얻으려면 `java.util.concurrent` 패키지의 **동시성 컬렉션**을 사용해야 합니다.

* **기본 컬렉션의 한계**: 멀티스레드 환경에서 **데이터 충돌(Race Condition)** 발생 위험이 높습니다.
* **해결책**:
    * **동시성 컬렉션 활용**: `java.util.concurrent` 패키지는 내부적으로 **최적화된 동시성 제어 메커니즘**을 사용하여 안전성과 높은 처리량을 동시에 제공합니다.
    * **주요 예시**:
        * **큐/덱**: `BlockingQueue` (생산자-소비자 패턴), `ConcurrentLinkedQueue`, `ConcurrentLinkedDeque` (높은 동시성을 위한 락-프리 방식).
        * **맵**: `ConcurrentHashMap` (스레드-세이프한 Map).

**핵심**: 멀티스레딩의 효율성은 **작업 병렬화**와 함께 **안전하고 최적화된 동시성 자료구조의 선택**에 달려있습니다.


---

### B. Java 동시성: `Runnable` vs. `java.util.concurrent` (비동기 관점)

Java에서 **비동기 프로그래밍**은 작업을 메인 흐름과 독립적으로 실행하여 응답성을 높이는 기법입니다. 이를 위한 핵심 요소들은 다음과 같습니다.

---

#### B-1. `Runnable` (및 `Thread`): 비동기 작업의 '정의'와 '시작'

* **`Runnable`**: **비동기적으로 실행될 코드 블록**을 정의합니다. (예: `run()` 메서드 안의 로직)
* **`Thread`**: `Runnable`을 받아 새로운 실행 흐름(스레드)을 만들고 `start()` 메서드로 **비동기 실행을 시작**합니다. 호출 스레드는 이 작업의 완료를 기다리지 않고 즉시 다음 코드를 진행합니다.

---

#### B-2. `java.util.concurrent`: 비동기 작업의 '관리'와 '조율'

`java.util.concurrent` 패키지는 비동기 작업들을 **효율적이고 안전하게 관리하며, 스레드 간 협력을 돕는** 고수준 도구들을 제공합니다.

* **Executor Framework (실행 관리)**
    * **`ExecutorService`**: 스레드 풀을 통해 비동기 작업을 제출하고 실행하며, 스레드 관리를 추상화합니다.
    * **`Future` & `CompletableFuture`**: 비동기 작업의 **결과를 나중에 조회**하거나, 여러 비동기 작업들을 조합하고 체인화하는 메커니즘을 제공합니다.
* **동시성 컬렉션 (안전한 데이터 공유)**
    * `ConcurrentHashMap`, `BlockingQueue` 등: 여러 비동기 스레드들이 **안전하게 데이터를 공유**할 수 있도록 설계된 자료구조로, 데이터 충돌(Race Condition)을 방지합니다.
* **동기화 도구 (작업 흐름 조율)**
    * `Semaphore`, `CountDownLatch` 등: 여러 비동기 작업들이 특정 시점에서 서로 **기다리거나 조율**할 수 있도록 돕습니다.

---

**결론**: `Runnable`/`Thread`가 비동기 작업을 '시작'하는 기본적인 수단이라면, `java.util.concurrent`는 이 비동기 작업들을 **효율적이고 안정적으로 '관리하고 조율'**하는 데 필수적인 고수준 도구들을 제공합니다. 현대 Java 비동기 프로그래밍은 대부분 `java.util.concurrent`의 이점을 활용합니다.

---
