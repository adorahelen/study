# 자료구조 및 데이터 타입 개요

---

🔑 **1. Key-Value 자료형이란?**
데이터를 키(key)와 값(value)으로 짝지어 저장하는 자료형입니다.

🌍 **왜 여러 이름이 존재할까?**
본질은 같지만, 사용하는 언어나 환경, 목적에 따라 조금씩 다르게 구현되거나 쓰이기 때문에 다양한 이름으로 불립니다.

| 이름                 | 사용하는 언어나 환경            | 특징                                                                                                   |
| :------------------- | :------------------------------ | :----------------------------------------------------------------------------------------------------- |
| **Dictionary** | Python, Swift 등                | 가장 직관적인 이름. "사전"처럼 키를 찾으면 값을 알려줌.                                                 |
| **Map** or **HashMap** | Java, Kotlin 등                 | 보통 해시 함수를 써서 빠르게 키를 찾음. Java에서는 `HashMap`, `TreeMap` 등이 있음.                     |
| **Object** | JavaScript (비공식)             | 객체도 내부적으로 key-value 구조. 하지만 메서드도 가질 수 있어 더 확장된 개념.                         |
| **JSON** | 데이터 포맷 (JavaScript Object Notation) | 직렬화된 key-value 형태의 데이터. 사람이 읽기 쉬움. 네트워크 통신에서 자주 사용.                       |
| **Associative Array** | PHP, Perl 등                    | 배열처럼 보이지만 키로 접근하는 구조.                                                                  |
| **Hash Table** | 자료구조 용어                   | 내부 구조에 대한 명칭. 해시 함수를 써서 키와 값을 연결하는 방식으로 구현함.                                |

🧠 **쉽게 이해하자면**

* **자료구조 이름 (HashMap, Dictionary)** → 프로그래밍 언어에서 사용하는 이름
* **데이터 표현 포맷 (JSON)** → 데이터를 저장하거나 주고받을 때의 형식
* **객체 (Object)** → 특정 언어에서는 key-value처럼 보이지만 메서드 등을 포함하는 더 확장된 개념

📌 **정리**

* 이름이 다르다고 해서 본질이 다른 것은 아닙니다.
* 주로 사용하는 프로그래밍 언어나 상황에 따라 이름이 달라집니다.
* 핵심은 **"키로 값을 빠르게 찾는다"**는 점입니다.

---

## 2. 프로그래밍의 주요 자료형 (Data Types)

key-value 형태 외에도 프로그래밍에서 자주 쓰이는 다양한 자료형(Data Types)들을 카테고리별로 소개해 드릴게요.

### ✅ 2.1. 기본 자료형 (Primitive Types)

🧮 수치형, 논리형, 문자형 등 가장 기본적인 데이터 단위입니다.

| 자료형            | 설명             | 예시          |
| :---------------- | :--------------- | :------------ |
| **int** (정수)    | 정수를 저장      | `42`, `-3`    |
| **float** / **double** | 실수(소수점 있는 수) | `3.14`, `-0.5`  |
| **char** | 한 글자 문자 (C, Java 등) | `'A'`, `'z'`  |
| **boolean** | 참/거짓          | `true`, `false` |
| **string** | 문자열 (문자들의 묶음) | `"hello"`, `"123"` |

### ✅ 2.2. 컬렉션 자료형 (Collection Types)

📦 여러 값을 담는 구조입니다.

| 자료형               | 설명           | 예시 (Python 기준)           |
| :------------------- | :------------- | :--------------------------- |
| **List** / **Array** | 순서 있는 데이터 집합 | `[1, 2, 3]`                  |
| **Tuple** | 변경 불가능한 리스트 | `(1, 2, 3)`                  |
| **Set** | 중복 없는 집합 | `{1, 2, 3}`                  |
| **Dictionary** / **Map** | 키-값 쌍       | `{"name": "Alice"}`        |

### ✅ 2.3. 추상 자료형 (Abstract Data Types)

🏗 자료구조 설계에 자주 사용되는 개념들로, 특정 동작들을 정의합니다.

| 자료형          | 설명                 | 주요 동작               |
| :-------------- | :------------------- | :---------------------- |
| **Stack** | 후입선출 (LIFO)      | `push()`, `pop()`       |
| **Queue** | 선입선출 (FIFO)      | `enqueue()`, `dequeue()` |
| **Deque** | 양쪽에서 넣고 뺄 수 있는 큐 | `appendleft()`, `pop()` |
| **Linked List** | 노드가 연결된 리스트 | `head` → `node1` → `node2` → … |
| **Tree** | 계층 구조 자료구조   | 이진 트리, AVL 트리 등   |
| **Graph** | 정점과 간선으로 이루어진 구조 | 방향/무방향 그래프       |

### ✅ 2.4. 기타 특수 자료형 / 구조체

| 자료형               | 설명                                   | 예시                                    |
| :------------------- | :------------------------------------- | :-------------------------------------- |
| **Enum** | 열거형, 고정된 상수 집합               | `enum Color { RED, GREEN, BLUE }`       |
| **Struct** | 여러 타입을 묶은 사용자 정의 구조체 (C 등) | `struct Person { char name[20]; int age; };` |
| **Class** / **Object** | 데이터 + 기능 (OOP)                    | `class Car { ... }`                     |

---

## 3. JSON과의 차이점

🧩 **JSON은 실제 코드가 아닌 데이터를 저장하고 전달하기 위한 형식입니다.**

* JSON은 내부적으로 배열, 객체, 문자열, 숫자, 불리언, null 등 다양한 자료형을 포함할 수 있습니다.
* 대부분의 언어에서는 JSON 형식의 데이터를 읽어와 해당 언어의 객체나 Map/Dictionary 형태로 변환하여 다룹니다.

---

## 4. 요약

| 범주           | 대표 자료형                      |
| :------------- | :------------------------------- |
| **기본형** | `int`, `float`, `char`, `boolean`, `string` |
| **컬렉션형** | `list`, `set`, `tuple`, `dict`, `array` |
| **추상 자료형** | `stack`, `queue`, `tree`, `graph` |
| **특수형** | `enum`, `struct`, `class`, `object` |
| **데이터 포맷** | `JSON`, `XML`, `YAML` 등           |

---

---

# Java 핵심 자료구조 / 멀티 스레드(비동기)

- Java Collections Framework는 데이터를 효율적으로 저장하고 관리할 수 있도록 다양한 자료구조 클래스와 인터페이스를 제공합니다. 
- 멀티스레딩은 작업자(Thread)에 관한 것이고, 비동기는 작업(Task)에 관한 것


---

### 1. `List` (순서 유지, 중복 허용)

요소가 추가된 순서를 유지하며, 동일한 요소를 여러 번 저장할 수 있습니다.

* **`ArrayList`**
    * **특징**: 내부적으로 **배열**을 사용하여 데이터를 저장합니다. 인덱스를 통한 **요소 접근(읽기)이 빠릅니다.** 하지만 리스트 중간에 요소를 추가하거나 삭제할 경우, 뒤의 요소들을 이동시켜야 하므로 성능 저하가 발생할 수 있습니다. 동기화되지 않습니다.
    * **주요 용도**: 요소의 **읽기 빈도가 높고**, 삽입/삭제가 적은 경우에 적합합니다.
* **`LinkedList`**
    * **특징**: 내부적으로 **이중 연결 리스트** 구조를 사용합니다. 따라서 요소의 **추가 및 삭제가 빈번할 때 효율적**입니다. 하지만 특정 인덱스의 요소를 찾기 위해선 처음부터 순회해야 하므로 접근(읽기) 속도는 `ArrayList`보다 느립니다. 동기화되지 않습니다.
    * **주요 용도**: 요소의 **잦은 삽입/삭제**가 필요한 경우, 또는 큐(Queue)나 스택(Stack)처럼 동작할 때 유용합니다.

---

### 2. `Set` (순서 유지 안 함, 중복 허용 안 함)

요소의 저장 순서가 보장되지 않으며, 중복된 요소를 허용하지 않습니다. 유일한 값들을 저장할 때 사용됩니다.

* **`HashSet`**
    * **특징**: **해싱(hashing) 메커니즘**을 사용하여 데이터를 저장합니다. 요소의 삽입, 삭제, 검색이 매우 빠릅니다. 요소의 저장 순서는 보장되지 않습니다. 동기화되지 않습니다.
    * **주요 용도**: **중복 없는 빠른 데이터 저장 및 검색**이 필요한 경우에 적합합니다.
* **`TreeSet`**
    * **특징**: 내부적으로 **트리(Red-Black Tree)** 구조를 사용하여 요소를 저장합니다. 요소들을 **자동으로 정렬된 상태로 유지**하며, 중복을 허용하지 않습니다. `HashSet`보다 삽입/삭제/검색 성능은 약간 느리지만, 정렬된 데이터를 쉽게 얻을 수 있습니다.
    * **주요 용도**: **정렬된 중복 없는 데이터**가 필요할 때 사용됩니다.

---

### 3. `Map` (키-값 쌍, 키 중복 허용 안 함)

키(Key)와 값(Value)의 쌍으로 데이터를 저장합니다. 키는 유일해야 하며, 값은 중복될 수 있습니다.

* **`HashMap`**
    * **특징**: **해싱(hashing) 메커니즘**을 사용하여 키-값 쌍을 저장합니다. 키와 값의 저장 순서는 보장되지 않습니다. **가장 많이 사용되는 `Map` 구현체**로, 키를 통한 값의 검색이 매우 빠릅니다. 동기화되지 않습니다.
    * **주요 용도**: **빠른 데이터 검색 및 조작**이 필요하며, 순서가 중요하지 않은 경우에 사용됩니다.
* **`TreeMap`**
    * **특징**: 내부적으로 **트리(Red-Black Tree)** 구조를 사용하여 키-값 쌍을 저장합니다. 키를 **자동으로 정렬된 상태로 유지**합니다. `HashMap`보다 삽입/삭제/검색 성능은 약간 느리지만, 키를 기준으로 정렬된 데이터를 얻을 수 있습니다.
    * **주요 용도**: **키를 기준으로 정렬된 Map**이 필요할 때 사용됩니다.

---

### 4. `Queue` 및 `Deque` (데이터 처리 순서 관리)

데이터를 특정 순서에 따라 처리해야 할 때 사용되는 인터페이스입니다.

* **`Queue`**
    * **특징**: **FIFO(First-In, First-Out)**, 즉 먼저 들어온 요소가 먼저 나가는 선입선출 구조입니다.
    * **대표 구현체**:
        * **`LinkedList`**: 큐로도 사용할 수 있으며, `offer()`, `poll()`, `peek()` 등의 메서드를 제공합니다.
        * **`PriorityQueue`**: 요소의 **우선순위**에 따라 정렬되어 저장되며, 가장 높은 우선순위의 요소가 먼저 제거됩니다. FIFO 순서를 보장하지 않습니다.
    * **주요 용도**: 작업 대기열, 메시지 큐 등 순차적인 처리가 필요한 경우.
* **`Deque` (Double Ended Queue)**
    * **특징**: 양쪽 끝에서 요소를 추가하거나 제거할 수 있는 큐(양방향 큐)입니다. 스택(LIFO)과 큐(FIFO)의 기능을 모두 수행할 수 있습니다.
    * **대표 구현체**:
        * **`ArrayDeque`**: 내부적으로 동적 배열을 사용하여 구현된 덱입니다. `LinkedList`나 구형 `Stack` 클래스보다 **성능이 좋은 경우가 많아** 스택이나 큐의 대체제로 권장됩니다.
    * **주요 용도**: 스택 및 큐의 유연한 구현, 너비 우선 탐색(BFS) 등.

---

### A. 멀티스레딩과 Java 자료구조: 효율성을 위한 고려사항

Java의 표준 자료구조(`ArrayList`, `HashMap` 등)는 **단일 스레드용**으로 설계되어 **스레드-세이프하지 않습니다.**

멀티스레딩 환경에서 이들을 직접 사용하면 **데이터 손상이나 예측 불가능한 오류**가 발생하며, 이는 비효율적인 결과를 초래합니다.

진정한 효율성을 얻으려면 `java.util.concurrent` 패키지의 **동시성 컬렉션**을 사용해야 합니다.

* **기본 컬렉션의 한계**: 멀티스레드 환경에서 **데이터 충돌(Race Condition)** 발생 위험이 높습니다.
* **해결책**:
    * **동시성 컬렉션 활용**: `java.util.concurrent` 패키지는 내부적으로 **최적화된 동시성 제어 메커니즘**을 사용하여 안전성과 높은 처리량을 동시에 제공합니다.
    * **주요 예시**:
        * **큐/덱**: `BlockingQueue` (생산자-소비자 패턴), `ConcurrentLinkedQueue`, `ConcurrentLinkedDeque` (높은 동시성을 위한 락-프리 방식).
        * **맵**: `ConcurrentHashMap` (스레드-세이프한 Map).

**핵심**: 멀티스레딩의 효율성은 **작업 병렬화**와 함께 **안전하고 최적화된 동시성 자료구조의 선택**에 달려있습니다.


---

### B. Java 동시성: `Runnable` vs. `java.util.concurrent` (비동기 관점)

Java에서 **비동기 프로그래밍**은 작업을 메인 흐름과 독립적으로 실행하여 응답성을 높이는 기법입니다. 이를 위한 핵심 요소들은 다음과 같습니다.

---

#### B-1. `Runnable` (및 `Thread`): 비동기 작업의 '정의'와 '시작'

* **`Runnable`**: **비동기적으로 실행될 코드 블록**을 정의합니다. (예: `run()` 메서드 안의 로직)
* **`Thread`**: `Runnable`을 받아 새로운 실행 흐름(스레드)을 만들고 `start()` 메서드로 **비동기 실행을 시작**합니다. 호출 스레드는 이 작업의 완료를 기다리지 않고 즉시 다음 코드를 진행합니다.

---

#### B-2. `java.util.concurrent`: 비동기 작업의 '관리'와 '조율'

`java.util.concurrent` 패키지는 비동기 작업들을 **효율적이고 안전하게 관리하며, 스레드 간 협력을 돕는** 고수준 도구들을 제공합니다.

* **Executor Framework (실행 관리)**
    * **`ExecutorService`**: 스레드 풀을 통해 비동기 작업을 제출하고 실행하며, 스레드 관리를 추상화합니다.
    * **`Future` & `CompletableFuture`**: 비동기 작업의 **결과를 나중에 조회**하거나, 여러 비동기 작업들을 조합하고 체인화하는 메커니즘을 제공합니다.
* **동시성 컬렉션 (안전한 데이터 공유)**
    * `ConcurrentHashMap`, `BlockingQueue` 등: 여러 비동기 스레드들이 **안전하게 데이터를 공유**할 수 있도록 설계된 자료구조로, 데이터 충돌(Race Condition)을 방지합니다.
* **동기화 도구 (작업 흐름 조율)**
    * `Semaphore`, `CountDownLatch` 등: 여러 비동기 작업들이 특정 시점에서 서로 **기다리거나 조율**할 수 있도록 돕습니다.

---

**결론**: `Runnable`/`Thread`가 비동기 작업을 '시작'하는 기본적인 수단이라면, `java.util.concurrent`는 이 비동기 작업들을 **효율적이고 안정적으로 '관리하고 조율'**하는 데 필수적인 고수준 도구들을 제공합니다. 현대 Java 비동기 프로그래밍은 대부분 `java.util.concurrent`의 이점을 활용합니다.

---
